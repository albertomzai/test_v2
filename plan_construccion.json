{
  "api_contract": {
    "ruta": "/api/tasks",
    "metodo": "GET, POST",
    "descripcion": "Endpoint para listar y crear tareas.",
    "parametros_entrada": {
      "contenido": "string",
      "estado": "string"
    },
    "respuesta_esperada": {
      "tareas": "[{id: int, contenido: string, estado: string}]"
    }
  },
  "plan": [
    {
      "etapa": "backend",
      "tareas": [
        "Crear un proyecto Flask con la estructura de directorios base.",
        "Configurar la lectura y escritura del archivo 'tasks.json' para persistencia.",
        "Implementar el endpoint GET '/api/tasks' que devuelve todas las tareas en formato JSON.",
        "Implementar el endpoint POST '/api/tasks' que recibe JSON con contenido y estado, genera un ID \u00fanico, guarda la tarea y retorna la nueva tarea.",
        "Implementar el endpoint PUT '/api/tasks/<int:id>' que actualiza el contenido o estado de una tarea existente, persiste los cambios y devuelve la tarea actualizada.",
        "Implementar el endpoint DELETE '/api/tasks/<int:id>' que elimina la tarea del archivo y confirma con un mensaje JSON.",
        "Agregar manejo de errores y validaci\u00f3n de datos para cada endpoint.",
        "Configurar CORS para permitir peticiones desde el mismo dominio o localhost.",
        "Escribir pruebas unitarias b\u00e1sicas para los endpoints utilizando Flask\u2011testclient."
      ]
    },
    {
      "etapa": "frontend",
      "tareas": [
        "Crear un archivo 'index.html' con la estructura b\u00e1sica: encabezado, tres columnas y bot\u00f3n de agregar tarea.",
        "Dise\u00f1ar las columnas usando CSS Flexbox o Grid para una disposici\u00f3n vertical y responsiva.",
        "Agregar un formulario modal o inline para introducir el contenido de una nueva tarjeta, que env\u00ede datos al endpoint POST del backend.",
        "Renderizar las tarjetas dentro de sus columnas seg\u00fan su estado actual obtenidos desde GET '/api/tasks'.",
        "Implementar la edici\u00f3n inline: al hacer clic en el texto de una tarjeta se convierte en un campo editable y guarda cambios mediante PUT al backend.",
        "A\u00f1adir l\u00f3gica JavaScript para drag\u2011and\u2011drop entre columnas, actualizando el estado de la tarjeta con PUT al backend cuando se suelta.",
        "Incorporar manejo b\u00e1sico de errores en el frontend para mostrar notificaciones si alguna llamada a la API falla.",
        "Optimizar la actualizaci\u00f3n del DOM solo donde sea necesario (p.ej., re-renderizar la tarjeta que cambi\u00f3).",
        "Documentar los pasos de configuraci\u00f3n y despliegue dentro de un README breve."
      ]
    }
  ]
}